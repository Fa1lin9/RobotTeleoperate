#include "CrpPhysicalRobot.hpp"

CrpPhysicalRobot::CrpPhysicalRobot(const PhysicalRobot::config &config_){
    l_solver.gap=0.5;
    r_solver.gap=0.5;
    l_controller.max_vel=0.6;
    r_controller.max_vel=0.6;
}

CrpPhysicalRobot::~CrpPhysicalRobot(){

}

bool CrpPhysicalRobot::Connect(){
    // 如果是在成功连接之后调用的话
    // 就直接通过Flag来判断
    // 避免再次重复连接的操作
    if(this->connectFlag){
        std::cout<< GREEN
                 << typeid(*this).name()
                 << " is already connected ! "
                 << RESET << std::endl;
    }

    // Start to connect
    std::vector<string> productSerialNumbers = query_can();
    if (productSerialNumbers.empty())
    {
        std::cout << RED
                  << "Can't find any USB device, plz retry！"
                  << RESET << std::endl;
        return false;
    }
    else
    {
        std::cout << RED
                  << " The CAN device is Founded ! "
                  << RESET << std::endl;
        std::cout << CYAN
                  << "CAN device serial number："
                  << RESET;
        for (const string &serialNumber : productSerialNumbers)
        {
            std::cout << CYAN
                      << serialNumber
                      << RESET << std::endl;
        }
    }
    std::string ip = ip_address();
    cout << MAGENTA << " IP = " << ip << RESET << endl;

    bool startFlag = Start();
//    ti5_socket_server(0,0,SERVER_PORT);

    if(startFlag){
          std::cout << GREEN
                    << " Successfully initialized CAN ! "
                    << RESET << std::endl;

          this->connectFlag = true ;
    }
    return this->connectFlag;
}

bool CrpPhysicalRobot::Disconnect(){
    bool exitFlag = Exit();
    if(exitFlag){
          std::cout << RED
                    << " Successfully exited CAN ! "
                    << RESET << std:: endl;
          this->connectFlag = false;
    }
    return this->connectFlag;
}

bool CrpPhysicalRobot::isConnect(){
    if(this->connectFlag){
        std::cout<< RED << typeid(*this).name() << " is connected ! " << RESET << std::endl;
    } else {
        std::cout<< RED << typeid(*this).name() << " is not connected ! " << RESET << std::endl;
    }
    return this->connectFlag;
}

bool CrpPhysicalRobot::EmergencyStop(){
    brake(LEFT_ARM,0,0);
    brake(RIGHT_ARM,1,0);
    std:cout << RED
             << " Emergency Stop !!! "
             << RESET << std::endl;
    return true;
}

bool CrpPhysicalRobot::BackToZero(){
    if(!this->isConnect()){ return false; }

    // TODO

    return true;
}

std::vector<double> CrpPhysicalRobot::GetJointsAngle(){
    LOG_FUNCTION;
    if(!this->isConnect()){ return {}; }

    std::vector<double> jointsAngle;
    float currentAngle[this->dofArm];

    // For Left Arm
    get_current_angle(ArmSide::LEFT_ARM, currentAngle, 0, 0);
    for(size_t i = 0; i < this->dofArm; i++){
        jointsAngle.push_back(currentAngle[i]);
        std::cout << " Left Arm Joint"
                  << i << " : "
                  << currentAngle[i] << std::endl;
    }

    // For Right Arm
    get_current_angle(ArmSide::RIGHT_ARM, currentAngle, 0, 0);
    for(size_t i = 0; i < this->dofArm; i++){
        jointsAngle.push_back(currentAngle[i]);
        std::cout << " Right Arm Joint"
                  << i << " : "
                  << currentAngle[i] << std::endl;
    }



    return {};
}

void CrpPhysicalRobot::Info(){
    LOG_FUNCTION;
    ArmSide armSide;

    std::cout<< RED
             << " ------------------------------------------ "
             << RESET << std::endl;

    std::cout<< " Left Arm ID: " << Left_arm_id<<std::endl;
    std::cout<< " Right Arm ID: " << Right_arm_id<<std::endl;

    // for head
    {
        std::cout<< GREEN
                 << " Head's canDevice and canIndex : "
                 << RESET << std::endl;
        for(size_t i = 0;i < this->dofHead ;i++){
            std::cout << GREEN
                      << " canDevice: " << size_t(0)
                      << " canIndex " << this->headCanIndex[i]
                      << RESET << std::endl;
        }
    }

    std::cout<< RED
             << " ------------------------------------------ "
             << RESET << std::endl;

    // for Left Arm
    {
        std::cout<< YELLOW
                 << " Left arm's canDevice and canIndex : "
                 << RESET << std::endl;
        for(size_t i = 0;i < this->dofArm ;i++){
            std::cout << YELLOW
                      << " canDevice: " << size_t(0)
                      << " canIndex " << this->leftArmCanIndex[i]
                      << RESET << std::endl;
        }
    }

    std::cout<< RED
             << " ------------------------------------------ "
             << RESET << std::endl;

    // for Right Arm
    {
        std::cout<< BLUE
                 << " Right arm's canDevice and canIndex : "
                 << RESET << std::endl;
        for(size_t i = 0;i < this->dofArm ;i++){
            std::cout << BLUE
                      << " canDevice: " << size_t(0)
                      << " canIndex " << this->rightArmCanIndex[i]
                      << RESET << std::endl;
        }
    }

    std::cout<< RED
             << " ------------------------------------------ "
             << RESET << std::endl;

}

bool CrpPhysicalRobot::MoveJ(const std::vector<double> &jointsAngle_){
    if(!this->isConnect()){ return false; }
    float jointsAngle[7];

    for(size_t i=0;i<jointsAngle_.size();i++){
        jointsAngle[i] = static_cast<float>(jointsAngle_[i]);
    }

    joint_to_move(ArmSide::LEFT_ARM,jointsAngle,0,0);

    return true;
}

bool CrpPhysicalRobot::MoveL(){

    return true;
}
